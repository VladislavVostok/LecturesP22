### UseWhen

Метод UseWhen() на основании некоторого условия позволяет создать ответвление конвейера при обработке запроса:

|   |   |
|---|---|
|1|`public` `static` `IApplicationBuilder UseWhen (``this` `IApplicationBuilder app, Func<HttpContext,``bool``> predicate, Action<IApplicationBuilder> configuration);`|

Как и `Use()`, метод UseWhen() реализован как метод расширения для типа IApplicationBuilder.

В качестве параметра он принимает делегат `Func>HttpContext,bool>` - некоторое условие, которому должен соответствовать запрос. В этот делегат передается объект HttpContext. А возвращаемым типом должен быть тип `bool` - если запрос соответствует условию, то возвращается true, иначе возвращаеся false.

Последний параметр метода - делегат `Action<IApplicationBuilder>` представляет некоторые действия над объектом IApplicationBuilder, который передается в делегат в качестве параметра.

Рассмотрим небольшой пример:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28<br><br>29|`var builder = WebApplication.CreateBuilder();`<br><br>`var app = builder.Build();`<br><br>`app.UseWhen(`<br><br>    `context => context.Request.Path ==` `"/time"``,` `// если путь запроса "/time"`<br><br>    `appBuilder =>`<br><br>    `{`<br><br>        `// логгируем данные - выводим на консоль приложения`<br><br>        `appBuilder.Use(``async` `(context, next) =>`<br><br>        `{`<br><br>            `var time = DateTime.Now.ToShortTimeString();`<br><br>            `Console.WriteLine($``"Time: {time}"``);`<br><br>            `await` `next();`   `// вызываем следующий middleware`<br><br>        `});`<br><br>        `// отправляем ответ`<br><br>        `appBuilder.Run(``async` `context =>`<br><br>        `{`<br><br>            `var time = DateTime.Now.ToShortTimeString();`<br><br>            `await` `context.Response.WriteAsync($``"Time: {time}"``);`<br><br>        `});`<br><br>`});`<br><br>`app.Run(``async` `context =>`<br><br>`{`<br><br>    `await` `context.Response.WriteAsync(``"Hello METANIT.COM"``);`<br><br>`});`<br><br>`app.Run();`|

В данном случае метод `app.UseWhen()` в качестве первого параметра получает следующее условие:

|   |   |
|---|---|
|1|`context => context.Request.Path ==` `"/time"`|

Второй параметр определяет действие, в котором создается ответвление конвейера:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16|`appBuilder =>`<br><br>`{`<br><br>    `// логгируем данные - выводим на консоль приложения`<br><br>    `appBuilder.Use(``async` `(context, next) =>`<br><br>    `{`<br><br>        `var time = DateTime.Now.ToShortTimeString();`<br><br>        `Console.WriteLine($``"Time: {time}"``);`<br><br>        `await` `next();`   `// вызываем следующий middleware`<br><br>    `});`<br><br>    `appBuilder.Run(``async` `context =>`<br><br>    `{`<br><br>        `var time = DateTime.Now.ToShortTimeString();`<br><br>        `await` `context.Response.WriteAsync($``"Time: {time}"``);`<br><br>    `});`<br><br>`}`|

В данном действии в конвейер обработки запроса встраиваются два middleware - с помощью методов `Use()` и `Run()`. В первом middleware логгируем это время на консоль приложения. Во втором - терминальном компоненте middleware отправляем информацию о времени в ответ клиенту.

Если мы обращаемся к приложению по пути, который отличается от "/time", то условие в методе `UseWhen()` ложно, поэтому ответвления конвейера не выполняется. И выполняется middleware из метода `app.Run()`:

![Ответвление конвейера обработки запроса в ASP.NET Core и C#](https://metanit.com/sharp/aspnet6/pics/2.40.png)

Однако если мы обращаемся по пути "/time", то условие в методе `app.UseWhen()` будет истинно. Соответственно будет выполняться ответвление конвейера, который будет обрабатывать запрос. В итоге на консоль приложения, а также в браузере будет выводиться текущее время.

![Ответвление конвейера обработки запроса в ASP.NET Core и C#](https://metanit.com/sharp/aspnet6/pics/2.41.png)

Стоит отметить, что создание ветки происходит один раз при запуске приложения. Например, в примере выше мы видим, что получение времени производится в обоих middleware во встраиваемой ветки. Но что будет, если вынести получение времени во вне и не дублировать в каждом middleware, например, следующим образом:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28|`var builder = WebApplication.CreateBuilder();`<br><br>`var app = builder.Build();`<br><br>`app.UseWhen(`<br><br>    `context => context.Request.Path ==` `"/time"``,` `// если путь запроса "/time"`<br><br>    `appBuilder =>`<br><br>    `{`<br><br>        `var time = DateTime.Now.ToShortTimeString();`<br><br>        `// логгируем данные - выводим на консоль приложения`<br><br>        `appBuilder.Use(``async` `(context, next) =>`<br><br>        `{`<br><br>            `Console.WriteLine($``"Time: {time}"``);`<br><br>            `await` `next();`   `// вызываем следующий middleware`<br><br>        `});`<br><br>        `// отправляем ответ`<br><br>        `appBuilder.Run(``async` `context =>`<br><br>        `{`<br><br>            `await` `context.Response.WriteAsync($``"Time: {time}"``);`<br><br>        `});`<br><br>`});`<br><br>`app.Run(``async` `context =>`<br><br>`{`<br><br>    `await` `context.Response.WriteAsync(``"Hello METANIT.COM"``);`<br><br>`});`<br><br>`app.Run();`|

В этом случае время будет устанавливаться один раз - при запуске приложения и создании ветки в конвейер. Соответственно вне зависимости от того, сколько раз мы будем обращаться к приложению по пути "/time", мы будем получать одно и то же время.

В примере выше ветка конвейера завершалась терминальным компонентом, поэтому остальные действия в основной части конвейера не выполнялись. Однако мы можем также передать запрос на обработку из ветки в основной поток конвейера:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21|`var builder = WebApplication.CreateBuilder();`<br><br>`var app = builder.Build();`<br><br>`app.UseWhen(`<br><br>    `context => context.Request.Path ==` `"/time"``,` `// условие: если путь запроса "/time"`<br><br>    `appBuilder =>`<br><br>    `{`<br><br>        `appBuilder.Use(``async` `(context, next) =>`<br><br>        `{`<br><br>            `var time = DateTime.Now.ToShortTimeString();`<br><br>            `Console.WriteLine($``"Time: {time}"``);`<br><br>            `await` `next();`   `// вызываем следующий middleware`<br><br>        `});`<br><br>`});`<br><br>`app.Run(``async` `context =>`<br><br>`{`<br><br>    `await` `context.Response.WriteAsync(``"Hello METANIT.COM"``);`<br><br>`});`<br><br>`app.Run();`|

В данном случае, если запрос идет по пути "/time", сначала срабатывает ветка конвейера с компонентом, который логгирует время на консоль. А затем выполняется компоненте из `app.Run()`, который отправляет сообщение "Hello METANIT.COM":

![Ответвление конвейера обработки запроса с помощью UseWhen в ASP.NET Core и C#](https://metanit.com/sharp/aspnet6/pics/2.42.png)

Для большей читабельности также можно было бы вынести действия по созданию ветки конвейера в отдельный метод:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24|`var builder = WebApplication.CreateBuilder();`<br><br>`var app = builder.Build();`<br><br>`app.UseWhen(`<br><br>    `context => context.Request.Path ==` `"/time"``,` `// условие: если путь запроса "/time"`<br><br>    `HandleTimeRequest`<br><br>`);`<br><br>`app.Run(``async` `context =>`<br><br>`{`<br><br>    `await` `context.Response.WriteAsync(``"Hello METANIT.COM"``);`<br><br>`});`<br><br>`app.Run();`<br><br>`void` `HandleTimeRequest(IApplicationBuilder appBuilder)`<br><br>`{`<br><br>    `appBuilder.Use(``async` `(context, next) =>`<br><br>    `{`<br><br>        `var time = DateTime.Now.ToShortTimeString();`<br><br>        `Console.WriteLine($``"current time: {time}"``);`<br><br>        `await` `next();`   `// вызываем следующий middleware`<br><br>    `});`<br><br>`}`|

### MapWhen

Метод MapWhen(), как и метод `UseWhen()`, на основании некоторого условия позволяет создать ответвление конвейера:

|   |   |
|---|---|
|1|`public` `static` `IApplicationBuilder MapWhen (``this` `IApplicationBuilder app, Func<HttpContext,``bool``> predicate, Action<IApplicationBuilder> configuration);`|

Метод MapWhen() также реализован как метод расширения для типа IApplicationBuilder, принимает те же параметры, что и `UseWhen()`, и работает во многом аналогичным образом:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18|`var builder = WebApplication.CreateBuilder();`<br><br>`var app = builder.Build();`<br><br>`app.MapWhen(`<br><br>    `context => context.Request.Path ==` `"/time"``,` `// условие: если путь запроса "/time"`<br><br>    `appBuilder => appBuilder.Run(``async` `context =>`<br><br>    `{`<br><br>        `var time = DateTime.Now.ToShortTimeString();`<br><br>        `await` `context.Response.WriteAsync($``"current time: {time}"``);`<br><br>    `})`<br><br>`);`<br><br>`app.Run(``async` `context =>`<br><br>`{`<br><br>    `await` `context.Response.WriteAsync(``"Hello METANIT.COM"``);`<br><br>`});`<br><br>`app.Run();`|

Здесь опять же, если запрошен путь "/time", то срабатывает ветка конвейера, созданная методом `app.MapWhen()`, в которой клиенту отправляется текущее время. Если путь запроса другой, то срабатывается основной поток конвейера, в котором отправляется сообщение "Hello METANIT.COM".