
Элементы управления представляют собой визуальные классы, которые получают введенные пользователем данные и могут инициировать различные события. Все элементы управления наследуются от класса Control и поэтому имеют ряд общих свойств:

- Anchor: Определяет, как элемент будет растягиваться
- BackColor: Определяет фоновый цвет элемента
- BackgroundImage: Определяет фоновое изображение элемента
- ContextMenu: Контекстное меню, которое открывается при нажатии на элемент правой кнопкой мыши. Задается с помощью элемента ContextMenu
- Cursor: Представляет, как будет отображаться курсор мыши при наведении на элемент
- Dock: Задает расположение элемента на форме
- Enabled: Определяет, будет ли доступен элемент для использования. Если это свойство имеет значение False, то элемент блокируется.
- Font: Устанавливает шрифт текста для элемента
- ForeColor: Определяет цвет шрифта
- Location: Определяет координаты верхнего левого угла элемента управления
- Name: Имя элемента управления
- Size: Определяет размер элемента
- Width: ширина элемента
- Height: высота элемента
- TabIndex: Определяет порядок обхода элемента по нажатию на клавишу Tab
- Tag: Позволяет сохранять значение, ассоциированное с этим элементом управления

## 4.1. Кнопка (Button)

### Кнопка

Наиболее часто используемым элементом управления является кнопка. Обрабатывая событие нажатия кнопки, мы может производить те или иные действия.

При нажатии на кнопку на форме в редакторе Visual Studio мы по умолчанию попадаем в код обработчика события `Click`, который будет выполняться при нажатии:

```cs
private void button1_Click(object sender, EventArgs e)
{
    MessageBox.Show("Hello World");
}
```

### Оформление кнопки

Чтобы управлять внешним отображением кнопки, можно использовать свойство **FlatStyle**. Оно может принимать следующие значения:

- Flat - Кнопка имеет плоский вид
    
- Popup - Кнопка приобретает объемный вид при наведении на нее указателя, в иных случаях она имеет плоский вид
    
- Standard - Кнопка имеет объемный вид (используется по умолчанию)
    
- System - Вид кнопки зависит от операционной системы
    

### Изображение на кнопке

Как и для многих элементов управления, для кнопки можно задавать изображение с помощью свойства BackgroundImage. Однако мы можем также управлять размещением текста и изображения на кнопки. Для этого надо использовать свойство TextImageRelation. Оно приобретает следующие значения:

- Overlay: текст накладывается на изображение
    
- ImageAboveText: изображение располагается над текстом
    
- TextAboveImage: текст располагается над изображением
    
- ImageBeforeText: изображение располагается перед текстом
    
- TextBeforeImage: текст располагается перед изображением
    

Например, установим для кнопки изображение. Для этого выберем кнопку и в окне Свойств нажмем на поле Image (не путать с BackgroundImage). Нам откроется диалоговое окно установи изображения:

![Установка изображения для кнопки](https://metanit.com/sharp/windowsforms/pics/4.1.png)

В этом окне выберем опцию `Local Resource` и нажмем на кнопку `Import`, после чего нам откроется диалоговое окно для выбора файла изображения.

После выбора изображения мы можем установить свойство ImageAlign, которое управляет позиционированием изображения на кнопке:

![ImageAlign](https://metanit.com/sharp/windowsforms/pics/4.2.png)

Нам доступны 9 вариантов, с помощью которых мы можем прикрепить изображение к определенной стороне кнопки. Оставим здесь значение по умолчанию - `MiddleCenter`, то есть позиционирование по центру.

Затем перейдем к свойству `TextImageRelation` и установим для него значение `ImageBeforeText`. В итоге мы получим кнопку, где сразу после изображения идет надпись на кнопке:

![Кнопка с изображением в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.3.png)

### Клавиши быстрого доступа

При работе с формами при использовании клавиатуры очень удобно пользоваться клавишами быстрого доступа. При нажатии на клавиатуре комбинации клавиш At+некоторый символ, будет вызываться определенная кнопка. Например, зададим для некоторой кнопки свойство Text равное `&Аватар`. Первый знак - амперсанд - определяет ту букву, которая будет подчеркнута. В данном случае надпись будет выглядеть как Аватар. И теперь чтобы вызвать событие Click, нам достаточно нажать на комбинацию клавиш Alt+А.

### Кнопки по умолчанию

Форма, на которой размещаются все элементы управления, имеет свойства, позволяющие назначать кнопку по умолчанию и кнопку отмены.

Так, свойство формы `AcceptButton` позволяет назначать кнопку по умолчанию, которая будет срабатывать по нажатию на клавишу Enter.

Аналогично работает свойство формы `CancelButton`, которое назначает кнопку отмены. Назначив такую кнопку, мы можем вызвать ее нажатие, нажав на клавишу Esc.

## 4.2. Метки и ссылки

### Label

Для отображения простого текста на форме, доступного только для чтения, служит элемент Label. Чтобы задать отображаемый текст метки, надо установить свойство `Text` элемента.

### LinkLabel

Особый тип меток представляют элементы LinkLabel, которые предназначены для вывода ссылок, которые аналогичны ссылкам, размещенным на стандартных веб-станиц.

Также, как и с обычными ссылками на веб-страницах, мы можем по отношению к данному элементу определить три цвета:

- Свойство ActiveLinkColor задает цвет ссылки при нажатии
    
- Свойство LinkColor задает цвет ссылки до нажатия, по которой еще не было переходов
    
- Свойство VisitedLinkColor задает цвет ссылки, по которой уже были переходы
    

Кроме цвета ссылки для данного элемента мы можем задать свойство LinkBehavior, которое управляет поведением ссылки. Это свойство принимает четыре возможных значения:

- SystemDefault: для ссылки устанавливаются системные настройки
    
- AlwaysUnderline: ссылка всегда подчеркивается
    
- HoverUnderline: ссылка подчеркивается только при наведении на нее курсора мыши
    
- NeverUnderline: ссылка никогда не подчеркивается
    

По умолчанию весь текст на данном элементе считается ссылкой. Однако с помощью свойства LinkArea мы можем изменить область ссылки. Например, мы не хотим включать в ссылку первые шесть символов. Для этого задаем подсвойство `Start`:

![Настройка элемента LinkLabel в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.4.png)

Чтобы выполнить переход по ссылке по нажатию на нее, надо дополнительно написать код. Данный код должен обрабатывать событие `LinkClicked`, которое есть у элемента LinkLabel. Например, пусть у нас на форме есть элемент ссылки называется linkLabel1 и который содержит некоторую ссылку:


Чтобы перейти по ссылке, зададим обработчик LinkClicked:

```cs
public partial class Form1: Form
{ 
    public Form1()

    {

        InitializeComponent();

        // задаем обработчик события

        linkLabel1.LinkClicked += linkLabel1_LinkClicked;

    }

    private void linkLabel1_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)

    {

System.Diagnostics.Process.Start("C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe", linkLabel1.Text);

    }

}
```

Метод `System.Diagnostics.Process.Start()` откроет данную ссылку в веб-браузере, который установлен в системе браузером по умолчанию.


## 4.3. Текстовое поле TextBox


Для ввода и редактирования текста предназначены текстовые поля - элемент TextBox. Так же как и у элемента Label текст элемента TextBox можно установить или получить с помощью свойства Text.

По умолчанию при переносе элемента с панели инструментов создается однострочное текстовое поле. Для отображения больших объемов информации в текстовом поле нужно использовать его свойства `Multiline` и `ScrollBars`. При установке для свойства `Multiline` значения true, все избыточные символы, которые выходят за границы поля, будут переноситься на новую строку.

Кроме того, можно сделать прокрутку текстового поля, установив для его свойства `ScrollBars` одно из значений:

- None: без прокруток (по умолчанию)
    
- Horizontal: создает горизонтальную прокрутку при длине строки, превышающей ширину текстового поля
    
- Vertical: создает вертикальную прокрутку, если строки не помещаются в текстовом поле
    
- Both: создает вертикальную и горизонтальную прокрутку
    

![Элемент TextBox в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.6.png)

### Автозаполнение текстового поля

Элемент TextBox обладает достаточными возможностями для создания автозаполняемого поля. Для этого нам надо привязать свойство **AutoCompleteCustomSource** элемента TextBox к некоторой коллекции, из которой берутся данные для заполнения поля.

Итак, добавим на форму текстовое поле и пропишем в код события загрузки следующие строки:

```cs
public partial class Form1: Form

{

    public Form1()

    {

        InitializeComponent();

        AutoCompleteStringCollection source = new AutoCompleteStringCollection()

        {

            "Кузнецов",

            "Иванов",

            "Петров",

            "Кустов"

        };

        textBox1.AutoCompleteCustomSource = source;

        textBox1.AutoCompleteMode = AutoCompleteMode.SuggestAppend;

        textBox1.AutoCompleteSource = AutoCompleteSource.CustomSource;

    }

}
```

![Автозаполнение текстового поля](https://metanit.com/sharp/windowsforms/pics/4.7.png)

Режим автодополнения, представленный свойством AutoCompleteMode, имеет несколько возможных значений:

- None: отсутствие автодополнения
    
- Suggest: предлагает варианты для ввода, но не дополняет
    
- Append: дополняет введенное значение до строки из списка, но не предлагает варианты для выбора
    
- SuggestAppend: одновременно и предлагает варианты для автодополнения, и дополняет введенное пользователем значение
    

### Перенос по словам

Чтобы текст в элементе TextBox переносился по словам, надо установить свойство **WordWrap** равным `true`. То есть если одно слово не умещается на строке, то но переносится на следующую. Данное свойство будет работать только для многострочных текстовых полей.

### Ввод пароля

Также данный элемент имеет свойства, которые позволяют сделать из него поле для ввода пароля. Так, для этого надо использовать PasswordChar и UseSystemPasswordChar.

Свойство PasswordChar по умолчанию не имеет значение, если мы установим в качестве него какой-нибудь символ, то этот символ будут отображаться при вводе любых символов в текстовое поле.

Свойство UseSystemPasswordChar имеет похожее действие. Если мы установим его значение в `true`, то вместо введенных символов в текстовом поле будет отображаться знак пароля, принятый в системе, например, точка.

### Событие TextChanged

Из всех событий элемента TextBox следует отметить событие `TextChanged`, которое срабатывает при изменении текста в элементе. Например, поместим на форму кроме текстового поля метку и сделаем так, чтобы при изменении текста в текстовом поле также менялся текст на метке:

```cs
public partial class Form1: Form

{

    public Form1()

    {

        InitializeComponent();

        textBox1.TextChanged += textBox1_TextChanged;

    }

    private void textBox1_TextChanged(object sender, EventArgs e)

    {

        label1.Text = textBox1.Text;

    }

}
```

![Событие TextChanged](https://metanit.com/sharp/windowsforms/pics/4.10.png)


## 4.4. MaskedTextBox


Элемент MaskedTextBox по сути представляет обычное текстовое поле. Однако данные элемент позволяет контролировать ввод пользователя и проверять его автоматически на наличие ошибок.

Чтобы контролировать вводимые в поле символы, надо задать маску. Для задания маски можно применять следующие символы:

- `0`: Позволяет вводить только цифры
    
- `9`: Позволяет вводить цифры и пробелы
    
- `#`: Позволяет вводить цифры, пробелы и знаки '+' и '-'
    
- `L`: Позволяет вводить только буквенные символы
    
- `?`: Позволяет вводить дополнительные необязательные буквенные символы
    
- `A`: Позволяет вводить буквенные и цифровые символы
    
- `.`: Задает позицию разделителя целой и дробной части
    
- `,`: Используется для разделения разрядов в целой части числа
    
- `:`: Используется в временных промежутках - разделяет часы, минуты и секунды
    
- `/`: Используется для разделения дат
    
- `$`: Используется в качестве символа валюты
    

Чтобы задать маску, надо установить свойство `Mask` элемента. Найдя это свойство в окне свойств(Porperties), нажмем на него и нам отобразится окно для задания одного из стандартных шаблонов маски. В частности мы можем выбрать Phone number (Телефонный номер), который подразумевает ввод в текстовое поле только телефонного номера:

![Шаблоны элемента MaskedTextBox](https://metanit.com/sharp/windowsforms/pics/4.8.png)

Теперь при запуске мы сможем ввести в текстовое поле только цифры, получив в итоге телефонный номер.

Теперь сделаем свою маску. Например, создадим маску для ввода инициалов имени и отчества и фамилий ограниченной длины в текстовое поле. Для этого присвоим свойству `Mask` значение `L.L.L?????????`. Тогда ввод в текстовое поле будет выглядеть следующим образом:

![Элемент MaskedTextBox в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.9.png)

Данный элемент также представляет нам ряд свойств, которые можно использовать для управления вводом. Так, свойство BeepOnError при установке значения `true` подает звуковой сигнал при введении некорректного символа.

Свойство HidePromptOnLeave при установке в `true` при потери текстовым полем фокуса скрывает, указанные в PromptChar

Свойство PromptChar указывает на символ, который отображается в поле на месте ввода символов. По умолчанию стоит знак подчеркивания.

Свойство AsciiOnly при значении `true` позволяет вводить только asci-символы, то есть символы из диапазона A-Z и a-z.


## 4.5. Radiobutton и CheckBox

### CheckBox

Элемент CheckBox или флажок предназначен для установки одного из двух значений: отмечен или не отмечен. Чтобы отметить флажок, надо установить у его свойства Checked значение `true`.

Кроме свойства `Checked` у элемента CheckBox имеется свойство CheckState, которое позволяет задать для флажка одно из трех состояний - Checked (отмечен), Indeterminate (флажок не определен - отмечен, но находится в неактивном состоянии) и Unchecked (не отмечен)

![Элемент CheckBox в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.11.png)

Также следует отметить свойство `AutoCheck` - если оно имеет значение `false`, то мы не можем изменять состояние флажка. По умолчанию оно имеет значение `true`.

При изменении состояния флажка он генерирует событие CheckedChanged. Обрабатывая это событие, мы можем получать измененный флажок и производить определенные действия:

```cs
private void checkBox_CheckedChanged(object sender, EventArgs e)
{
    CheckBox checkBox = (CheckBox)sender; // приводим отправителя к элементу типа CheckBox
    if (checkBox.Checked == true)
    {
        MessageBox.Show("Флажок " +checkBox.Text + "  теперь отмечен");
    }
    else
    {
        MessageBox.Show("Флажок " +checkBox.Text + "  теперь не отмечен");
    }     
}
```

### Radiobutton

На элемент CheckBox похож элемент RadioButton или переключатель. Переключатели располагаются группами, и включение одного переключателя означает отключение всех остальных.

Чтобы установить у переключателя включенное состояние, надо присвоить его свойству `Checked` значение `true`.

Для создания группы переключателей, из которых можно бы было выбирать, надо поместить несколько переключателей в какой-нибудь контейнер, например, в элементы GroupBox или Panel. Переключатели. находящиеся в разных контейнерах, будут относиться к разным группам:

![Элемент RadioButton в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.12.png)

Похожим образом мы можем перехватывать переключение переключателей в группе, обрабатывая событие `CheckedChanged`. Связав каждый переключатель группы с одним обработчиком данного события, мы сможем получить тот переключатель, который в данный момент выбран:

```cs
private void radioButton_CheckedChanged(object sender, EventArgs e)
{
    // приводим отправителя к элементу типа RadioButton
    RadioButton radioButton = (RadioButton)sender;

    if (radioButton.Checked)
    {
        MessageBox.Show("Вы выбрали " +radioButton.Text);
    }       
}
```

## 4.6. ListBox


Элемент ListBox представляет собой простой список. Ключевым свойством этого элемента является свойство Items, которое как раз и хранит набор всех элементов списка.

Элементы в список могут добавляться как во время разработки, так и программным способом. В Visual Studio в окне Properties (Свойства) для элемента ListBox мы можем найти свойство Items. После двойного щелчка на свойство нам отобразится окно для добавления элементов в список:

![Добавление объектов в элемент ListBox](https://metanit.com/sharp/windowsforms/pics/4.13.png)

В пустое поле мы вводим по одному элементу списка - по одному на каждой строке. После этого все добавленные нами элементы окажутся в списке, и мы сможем ими управлять:

![Элемент ListBox в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.14.png)

### Программное управление элементами в ListBox

#### Добавление элементов

Итак, все элементы списка входят в свойство `Items`, которое представляет собой коллекцию. Для добавления нового элемента в эту коллекцию, а значит и в список, надо использовать метод Add, например: `listBox1.Items.Add("Новый элемент");`. При использовании этого метода каждый добавляемый элемент добавляется в конец списка.

Можно добавить сразу несколько элементов, например, массив. Для этого используется метод `AddRange`:

```cs
string[] countries = { "Бразилия", "Аргентина", "Чили", "Уругвай", "Колумбия" };

listBox1.Items.AddRange(countries);
```

#### Вставка элементов

В отличие от простого добавления вставка производится по определенному индексу списка с помощью метода `Insert`:

```cs
listBox1.Items.Insert(1, "Парагвай");
```

В данном случае вставляем элемент на вторую позицию в списке, так как отсчет позиций начинается с нуля.

#### Удаление элементов

Для удаления элемента по его тексту используется метод `Remove`:

```cs
listBox1.Items.Remove("Чили");

```

Чтобы удалить элемент по его индексу в списке, используется метод `RemoveAt`:
```cs
listBox1.Items.RemoveAt(1);
```

Кроме того, можно очистить сразу весь список, применив метод `Clear`:

```cs
listBox1.Items.Clear();
```

#### Доступ к элементам списка

Используя индекс элемента, можно сам элемент в списке. Например, получим первый элемент списка:

```cs
string firstElement = listBox1.Items[0];
```

Свойство `Count` возвращает количество элементов в списке:

```cs
int number = listBox1.Items.Count;
```

#### Выделение элементов списка

При выделении элементов списка мы можем ими управлять как через индекс, так и через сам выделенный элемент. Получить выделенные элементы можно с помощью следующих свойств элемента ListBox:

- SelectedIndex: возвращает или устанавливает номер выделенного элемента списка. Если выделенные элементы отсутствуют, тогда свойство имеет значение -1
    
- SelectedIndices: возвращает или устанавливает коллекцию выделенных элементов в виде набора их индексов
    
- **SelectedItem**: возвращает или устанавливает текст выделенного элемента
    
- SelectedItems: возвращает или устанавливает выделенные элементы в виде коллекции
    

По умолчанию список поддерживает выделение одного элемента. Чтобы добавить возможность выделения нескольких элементов, надо установить у его свойства `SelectionMode` значение `MultiSimple`.

Чтобы выделить элемент програмно, надо применить метод `SetSelected(int index, bool value)`, где index - номер выделенного элемента. Если второй параметр - value имеет значение `true`, то элемент по указанному индексу выделяется, если `false`, то выделение наоборот скрывается:

```cs
listBox1.SetSelected(2, true); // будет выделен третий элемент
```

Чтобы снять выделение со всех выделенных элементов, используется метод `ClearSelected`.

### Событие SelectedIndexChanged

Из всех событий элемента ListBox надо отметить в первую очередь событие `SelectedIndexChanged`, которое возникает при изменении выделенного элемента:

```cs
public partial class Form1: Form
{
    public Form1()
    {
        InitializeComponent();
        string[] countries = { "Бразилия", "Аргентина", "Чили",  "Уругвай", "Колумбия" };
        listBox1.Items.AddRange(countries);
        listBox1.SelectedIndexChanged += listBox1_SelectedIndexChanged;
    }

    void listBox1_SelectedIndexChanged(object sender, EventArgs e)
    {
        string selectedCountry = listBox1.SelectedItem.ToString();
        MessageBox.Show(selectedCountry);
    }
}
```

В данном случае по выбору элемента списка будет отображаться сообщение с выделенным элементом.



```cs
using System;
using System.Drawing;
using System.Windows.Forms;

namespace EscapeButtonApp
{
    public class MainForm : Form
    {
        private Button escapeButton;
        private Random random;

        public MainForm()
        {
            // Настройка формы
            this.Text = "Убегающая кнопка";
            this.Size = new Size(400, 300);

            // Создание кнопки
            escapeButton = new Button
            {
                Text = "Поймай меня!",
                Size = new Size(100, 50),
                Location = new Point(150, 100)
            };

            // Добавление кнопки на форму
            this.Controls.Add(escapeButton);

            // Генератор случайных чисел
            random = new Random();

            // Подписка на событие MouseMove для кнопки
            escapeButton.MouseMove += EscapeButton_MouseMove;
        }

        private void EscapeButton_MouseMove(object sender, MouseEventArgs e)
        {
            // Новое случайное положение кнопки
            int maxX = this.ClientSize.Width - escapeButton.Width;
            int maxY = this.ClientSize.Height - escapeButton.Height;

            int newX = random.Next(0, maxX);
            int newY = random.Next(0, maxY);

            escapeButton.Location = new Point(newX, newY);
        }
    }
}

```

### Привязка данных в ListBox и ComboBox

Кроме прямого добавления элементов в коллекцию `Items` компонентов ListBox и ComboBox мы также можем использовать механизм привязки данных.

Привязка данных в ListBox и ComboBox реализуется с помощью следующих свойств:

- DataSource: источник данных - какой-нибудь массив или коллекция объектов
    
- DisplayMember: свойство объекта, которое будет использоваться для отображения в ListBox / ComboBox
    
- ValueMember: свойство объекта, которое будет использоваться в качестве его значения
    

Рассмотрим пример.

```cs
public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();

        List<Phone> phones = new List<Phone>
        {
            new Phone { Id=11, Name="Samsung Galaxy Ace 2", Year=2012},
            new Phone { Id=12, Name="Samsung Galaxy S4", Year=2013},
            new Phone { Id=13, Name="iPhone 6", Year=2014},
            new Phone { Id=14, Name="Microsoft Lumia 435", Year=2015},
            new Phone { Id=15, Name="Xiaomi Mi 5", Year=2015}
        };

        listBox1.DataSource = phones;
        listBox1.DisplayMember = "Name";
        listBox1.ValueMember = "Id";

        listBox1.SelectedIndexChanged += listBox1_SelectedIndexChanged;
    }

    void listBox1_SelectedIndexChanged(object sender, EventArgs e)
    {
        // получаем id выделенного объекта
        int id = (int)listBox1.SelectedValue;

        // получаем весь выделенный объект
        Phone phone = (Phone)listBox1.SelectedItem;
        MessageBox.Show(id.ToString() + ". " + phone.Name);
    }
}
class Phone
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Year { get; set; }
}
```

Итак, на форме у нас есть список ListBox с именем listBox1. В коде имеется класс Phone с тремя свойствами, объекты которого мы хотим выводить в список. В отличие от предыдущих тем эта задача сложнее, так как раньше мы выводили обычные строки, тут же у нас сложные объекты.

Для вывода используем механизм привязки. Сначала устанавливаем список телефонов в качестве источника данных:

```cs
listBox1.DataSource = phones;
```

Затем устанавливаем в качестве отображаемого свойства свойство Name класса Phone, а в качестве свойства значения - свойство Id:

```cs
listBox1.DisplayMember = "Name";
listBox1.ValueMember = "Id";
```

Значение отображаемого свойства мы затем увидим в списке. Оно будет представлять каждый отдельный объект Phone.

С помощью же свойства значения, которым является свойство Id, мы можем упростить работу с источником данных. В данном случае оно не играет большой роли. Но если бы мы использовали в качестве источника данных некоторый набор объектов из базы данных, то с помощью id нам было проще удалять, обновлять и взаимодействовать с базой данных.

И теперь если мы выделим какой-то объект, то свойство SelectedItem элементы ListBox будет содержать объект Phone, у которого мы можем получить значения свойств:

```cs
Phone phone = (Phone)listBox1.SelectedItem;
string name = phone.Name;
```

А выделенное значение, то есть значение свойства Id выделенного телефона, будет находиться в свойстве SelectedValue.

И если мы запустим приложение, то увидим все отображаемые телефоны:

![Привязка в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.20.png)

Все то же самое характерно и для элемента ComboBox. Пусть кроме ListBoxa на форме есть ComboBox:

```cs
public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();

        List<Phone> phones = new List<Phone>
        {
            new Phone { Id=11, Name="Samsung Galaxy Ace 2", Year=2012},
            new Phone { Id=12, Name="Samsung Galaxy S4", Year=2013},
            new Phone { Id=13, Name="iPhone 6", Year=2014},
            new Phone { Id=14, Name="Microsoft Lumia 435", Year=2015},
            new Phone { Id=15, Name="Xiaomi Mi 5", Year=2015}
        };

        comboBox1.DataSource = phones;
        comboBox1.DisplayMember = "Name";
        comboBox1.ValueMember = "Id";

        comboBox1.SelectedIndexChanged += comboBox1_SelectedIndexChanged;

        listBox1.DisplayMember = "Name";
        listBox1.ValueMember = "Id";
    }

    void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
    {
        Phone phone = (Phone)comboBox1.SelectedItem;
        listBox1.Items.Add(phone);
    }
}

class Phone
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Year { get; set; }
}
```

Здесь также для комбобокса устанавливается привязка, а также отображаемое свойство и свойство значения. Кроме того, здесь обрабатывается событие выбора элемента в комбобоксе так, чтобы выбранный элемент попадал в ListBox.

![Привязка даных в ComboBox](https://metanit.com/sharp/windowsforms/pics/4.21.png)

В отличие от ListBoxa ComboBox имеет три свойства для обработки выделенного объекта:

- `SelectedItem`: выбранный элемент
    
- `SelectedValue`: значение свойства значения, в данном случае свойство Id
    
- `SelectedText`: значение свойства отображение, в данном случае свойство Name класса Phone

## 4.7. CheckedListBox

Элемент CheckedListBox представляет симбиоз компонентов ListBox и CheckBox. Для каждого элемента такого списка определено специальное поле CheckBox, которое можно отметить.

Все элементы задаются в CheckedListBox задаются в свойстве Items. Также, как и для элементов ListBox и ComboBox, мы можем задать набор элементов. По умолчанию для каждого добавляемого нового элемента флажок не отмечен:

![Элемент CheckedListBox в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.17.png)

Чтобы поставить отметку в checkBox рядом с элементом в списке, нам надо сначала выделить элемент и дополнительным щелчком уже установить флажок. Однако это не всегда удобно, и с помощью свойства CheckOnClick и установке для него значения `true` мы можем определить сразу выбор элемента и установку для него флажка в один клик.

Другое свойство MultiColumn при значении `true` позволяет сделать многоколоночный список, если элементы не помещаются по длине:

![Свойство MultiColumn в CheckedListBox](https://metanit.com/sharp/windowsforms/pics/4.18.png)

Выделенный элемент мы также можем получить с помощью свойства SelectedItem, а его индекс - с помощью свойства SelectedIndex. Но это верно только, если для свойства SelectionMode установлено значение `One`, что подразумевает выделение только одного элемента.

При установке для свойства `SelectionMode` значений `MultiSmple` и `MultiExtended` можно выбрать сразу несколько элементов, и тогда все выбранные элементы будут доступны в свойстве SelectedItems, а их индексы - в свойстве SelectedIndeces.

И поскольку мы можем поставить отметку не для всех выбранных элементов, то чтобы отдельно получить отмеченные элементы, у CheckedListBox имеются свойства CheckedItems и CheckedIndices.

Для добавления и удаления элементов в CheckedListBox определены все те же методы, что и в LstBox:

- `Add(item)`: добавляет один элемент
    
- `AddRange(array)`: добавляет в список массив элементов
    
- `Insert(index, item)`: добавляет элемент по определенному индексу
    
- `Remove(item)`: удаляет элемент
    
- `RemoveAt(index)`: удаляет элемент по определенному индексу
    
- `Clear()`: полностью очищает список
    

### SetItemChecked и SetItemCheckState

К особенностям элемента можно отнести методы SetItemChecked и SetItemCheckState. Метод `SetItemChecked` позволяет установить или сбросить отметку на одном из элементов. А метод `SetItemCheckState` позволяет установить флажок в одно из трех состояний: Checked (отмечено), Unchecked (неотмечено) и Indeterminate (промежуточное состояние):

```cs
heckedListBox1.SetItemChecked(0, true);
checkedListBox1.SetItemCheckState(1, CheckState.Indeterminate);
```

![Программный выбор элемента в CheckedListBox](https://metanit.com/sharp/windowsforms/pics/4.19.png)


## 4.8. NumericUpDown и DomainUpDown

### 4.8.1. NumericUpDown

Элемент NumericUpDown представляет пользователю выбор числа из определенного диапазона. Для определения диапазона чисел для выбора NumericUpDown имеет два свойства: Minimum (задает минимальное число) и Maximum (задает максимальное число).

Само значение элемента хранится в свойстве Value:

![NumericUpDown в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.22.png)

По умолчанию элемент отображает десятичные числа. Однако если мы установим его свойство Hexadecimal равным `true`, то элемент будет отображать все числа в шестнадцатеричной системе.

![Шестнадцатиричные числа в NumericUpDown](https://metanit.com/sharp/windowsforms/pics/4.23.png)

Даже если мы в коде установим обычное десятичное значение:

```cs
numericUpDown1.Value = 66;
```

то элемент все равно отобразит его в шестнадцатиричной системе.

Если мы хотим отображать в поле дробные числа, то можно использовать свойство DecimalPlaces, которое указывает, сколько знаков после запятой должно отображаться. По умолчанию это свойство равно нулю.

Также можно задать отображение тысячного разделителя. Для этого для свойства ThousandsSeparator надо установить значение `true`. Например, numericUpDown при `Value=1000,03`, `DecimalPlaces=2` и `ThousandsSeparator=true`:

![](https://metanit.com/sharp/windowsforms/pics/4.24.png)

При этом надо учитывать, что если мы устанавливаем значение для свойства Value в окне свойств, то там в качестве разделителя цеой и дробной части используется запятая. Если же мы устанавливаем данное свойство в коде, тогда в качестве разделителя используется точка.

По умолчанию при нажатии на стрелочки вверх-вниз на элементе значение будет увеличиваться, либо уменьшаться на единицу. Но с помощью свойства Increment можно задать другой шаг приращения, в том числе и дробный.

При работе с NumericUpDown следует учитывать, что его свойство `Value` (как и свойства `Minimum` и `Maximum`) хранит значение decimal. Поэтому в коде мы также должны с ним работать как с decimal, а не как с типом int или double.

### 4.8.2. DomainUpDown

Элемент DomainUpDown предназначен для ввода текстовой информации. Он имеет текстовое поле для ввода строки и две стрелки для перемещения по списку строк:

![Элемент DomainUpDown в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.25.png)

Список для DomainUpDown задается с помощью свойства Items. Список можно сразу упорядочить по алфавиту. Для этого надо свойству Sorted присвоить значение `true`.

Чтобы можно было циклично перемещаться по списку, то есть при достижении конца или начала списка его просмотр начинался с первого или последнего элемента, надо установить для свойства Wrap значение `true`.

В коде выбранное значение в DomainUpDown доступно через свойство Text. Например, добавим программно список строк в DomainUpDown и обработаем изменение выбора в списке:

```cs
public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();

        List<string> states = new List<string>
        {
            "Аргентина", "Бразилия", "Венесуэла", "Колумбия", "Чили"
        };

        // добавляем список элементов
        domainUpDown1.Items.AddRange(states);
        domainUpDown1.TextChanged += domainUpDown1_TextChanged;
    }
    // обработка изменения текста в элементе
    void domainUpDown1_TextChanged(object sender, EventArgs e)
    {
        MessageBox.Show(domainUpDown1.Text);
    }
}
```

Для обработки изменения текста здесь таке, как и для элемента TextBox, можно использовать событие `TextChanged`, в обработчике которого мы выводим выбранный текст в сообщение.


## 4.9. ImageList


ImageList не является визуальным элементом управления, однако он представляет компонент, который используется элементами управления. Он определяет набор изображений, который могут использовать такие элементы, как ListView или TreeView.

Чтобы его добавить в проект, его также можно перенести на форму с Панели Инструментов:

![Компонент ImageList в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.28.png)

Так как компонент не является визуальным элементом, то мы увидим его под формой.

Ключевым свойством ImageList является свойство Images, которое задает коллекцию изображений.

![Свойства ImageList](https://metanit.com/sharp/windowsforms/pics/4.29.png)

При выборе данного свойства нам окроется окно редактора изображений, в котором мы можем добавить новое изображение или удалить имеющееся.

![Images Collection Editor](https://metanit.com/sharp/windowsforms/pics/4.30.png)

Чтобы установить размер изображений для данного ImageList можно использовать его свойство ImageSize. По умолчанию ширина и высота имеют значение 16 пикселей, но мы можем установить любое другое, но не больше 256 пикселей.

Также можно добавлять/удалять изображения из списка программно:

```cs
imageList1.Images.Add(Image.FromFile(@""));
imageList1.Images.RemoveAt(0); // удаляем первое изображение
```

Чтобы делать разобраться, как использовать ImageList, добавим в него три изображения и поместим на форму три чекбокса. У каждого чекбокса уберем тест и установим свойство ImageList и укажем в свойстве ImageIndex индекс изобраения из imageList1:

![](https://metanit.com/sharp/windowsforms/pics/4.31.png)

И получим форму наподобие следующей:

![CheckBox и ImageList в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.32.png)


## 4.10. ListView

Элемент ListView представляет список, но с более расширенными возможностями, чем ListBox. В ListView можно отображать сложные данные в различных стобцах, можно задавать данным изображения и пиктограммы.

### ListViewItem

Все элементы, как и в других списковых визуальных компонентах, задаются с помощью свойства Items. Но в отличие от ListBox или ComboBox, если мы через панель Свойств откроем окно редактирования элементов ListView:

![ListViewItem](https://metanit.com/sharp/windowsforms/pics/4.26.png)

Каждый отдельный элемент в ListView представляет объект ListViewItem. В окне редактирования элементов мы также можем добавлять и удалять элементы списка. Но кроме того, здесь также мы можем выполнить дополнительную настройку элементов с помощью следующих свойств:

- BackColor: фоновый цвет элемента
    
- Checked: если равно true, то данный элемент будет отмечен
    
- Font: шрифт элемента
    
- ForeColor: цвет шрифта
    
- Text: текст элемента
    
- ToolTipText: текст всплывающей подсказки, устанавливаемой для элемента
    
- UseItemStyleForSubItems: если равно true, то стиль элемента будет также использоваться и для всех его подэлементов
    
- Group: задает фоновый цвет элемента
    
- ImageIndex: получает или задает индекс изображения, выводимого для данного элемента
    
- ImageKey: получает или задает индекс изображения для данного элемента
    
- StateImageIndex: получает или задает индекс изображения состояния (например установленного или снятого флажка, указывающего состояние элемента)
    
- SubItems: коллекция подэлементов для данного элемента ListViewItem
    
- Tag: тег элемента
    
- IdentCount: устанавливает отступ от границ ListViewItem до используемого им изображения
    

Это только те свойства, которые мы можем задать в окне редактирования элементов ListView. Но потом все добавляемые элементы мы сможем увидеть в ListView:

![Элемент ListView в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.27.png)

Чтобы добавить к элементам в ListView флажки, кроме задания свойства `Checked` у каждого отдельного элемента ListViewItem, надо также у свойства CheckBoxes у самого объекта ListView установить значение `true`.

### Изображения элементов

Для добавления элементам изображений у ListView есть несколько свойств:

- LargeImageList: задает список ImageList, изображения которого будут использоваться для крупных значков
    
- SmallImageList: задает список ImageList, изображения которого будут использоваться для мелких значков
    
- StateImageList: задает список ImageList, изображения которого будут использоваться для разных состояний
    

Пусть у нас есть некоторый ImageList с изображениями. Зададим этот ImageList для свойств LargeImageList и SmallImageList.

Тогда при добавлении новых элементов мы можем указать индекс изображение из ImageList, которое будет использоваться элементом:

![](https://metanit.com/sharp/windowsforms/pics/4.33.png)

Тогда в приложении вместе с текстыми метками элементов можно будет увидеть и изображения:

![](https://metanit.com/sharp/windowsforms/pics/4.34.png)

### Типы отображений

С помощью свойства View у элемента ListView можно задать тип отображения, который принимает следующие значения:

- Details: отображение в виде таблицы
    
- LargeIcon: набор крупных значков (применяется по умолчанию)
    
- List: список
    
- SmallIcon: набор мелких значков
    
- Tile: плитка
    

При отображении в виде таблицы также надо задать набор столбцов в свойстве `Columns` у ListView:

![](https://metanit.com/sharp/windowsforms/pics/4.35.png)

В данном случае я указал один столбец, у которого заголовок будет "Страна". Если у элементов ListViewItem были бы подэлементы, то можно было бы также задать и столбцы для подэлементов.

Кроме рассмотренных выше свойств ListView надо еще отметить некоторые. Свойство MultiSelect при установке в true позволяет выделять несколько строк в ListView одновременно.

Свойство Sorting позволяет задать режим сортировки в ListView. По умолчанию оно имеет значение `None`, но также можно установить сортировку по возрастанию (значение `Ascending`) или сортировку по убыванию (значение `Descending`)

### ListView. Практика

Выполним небольшую практическую задачу: выберем все названия файлов из какой-нибудь папки в ListView.

![Получение всех файлов в ListView](https://metanit.com/sharp/windowsforms/pics/4.36.png)

Во-первых добавим на форму элементы TextBox (для ввода названия папки, файлы которой надо получить), Button (для запуска получения) и ListView.

Чтобы все файлы имели какое-нибудь изображение, добавим на форму ImageList с именем imageList1 и поместим в него какую-нибудь картинку.

У ListView для свойства `View` установим значение `SmallIcon`.

Все остальное сделаем в коде формы:

```cs
using System;
using System.ComponentModel;
using System.IO;
using System.Windows.Forms;

namespace HelloApp
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();

            listView1.SmallImageList = imageList1;
        }

        private void button1_Click(object sender, EventArgs e)
        {
            string path = textBox1.Text;
            // получаем все файлы
            string[] files = Directory.GetFiles(path);
            // перебор полученных файлов
            foreach (string file in files)
            {
                ListViewItem lvi = new ListViewItem();
                // установка названия файла
                lvi.Text = file.Remove(0, file.LastIndexOf('\\') + 1);
                lvi.ImageIndex = 0; // установка картинки для файла
                // добавляем элемент в ListView
                listView1.Items.Add(lvi);
            }
        }
    }
}
```

## 4.11. TreeView


TreeView представляет визуальный элемент в виде дерева. Дерево содержит узлы, которые представляют объекты TreeNode. Узлы могут содержать другие подузлы и могут находиться как скрытом, так и в раскрытом состоянии. Все узлы содержатся в свойстве Nodes.

Если мы нажем в панели Свойств на свойство `Nodes`, то нам откроется окно редактирования узлов TreeView:

![TreeNode в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.37.png)

В этом окне мы можем добавить новые узлы, создать для них подузлы, удалить уже имеющиеся, настроить свойства узлов. Рассмотрим некоторые свойства, которые мы здесь может установить:

- BackColor: фоновый цвет узла
    
- Checked: если равно true, то данный узел будет отмечен флажком
    
- NodeFont: шрифт узла
    
- ForeColor: цвет шрифта
    
- Text: текст узла
    
- ImageIndex: получает или задает индекс изображения, выводимого для данного узла
    
- ImageKey: получает или задает индекс изображения для данного узла
    
- SelectedImageKey: получает или задает индекс изображения для данного узла в выбранном состоянии
    
- SelectedImageIndex: получает или задает индекс изображения, выводимого для данного узла в выбранном состоянии
    
- StateImageIndex: получает или задает индекс изображения состояния (например установленного или снятого флажка, указывающего состояние элемента)
    
- Tag: тег узла
    

И затем все добавленные узлы мы сможем увидеть в приложении на форме:

![Элемент TreeView в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.38.png)

Кроме данных свойств, управляющих визуализацией, элемент TreeNode имеет еще ряд важных свойств, которые мы можем использовать к коде:

- FirstNode: первый дочерний узел
    
- LastNode: последний дочерний узел
    
- NextNode: возвращает следующий сестринский узел по отношению к текущему
    
- NextVisibleNode: возвращает следующий видимый узел по отношению к текущему
    
- PrevNode: возвращает предыдущий сестринский узел по отношению к текущему
    
- PrevVisibleNode: возвращает предыдущий видимый узел по отношению к текущему
    
- Nodes: возвращает коллекцию дочерних узлов
    
- Parent: возвращает родительский узел для текущего узла
    
- TreeView: возвращает объект TreeView, в котором определен текущий узел
    

### Программное управление узлами

Рассмотрим программное добавление и удаление узлов:

```cs
TreeNode tovarNode = new TreeNode("Товары");
// Добавляем новый дочерний узел к tovarNode
tovarNode.Nodes.Add(new TreeNode("Смартфоны"));
// Добавляем tovarNode вместе с дочерними узлами в TreeView
treeView1.Nodes.Add(tovarNode);
// Добавляем второй очерний узел к первому узлу в TreeView
treeView1.Nodes[0].Nodes.Add(new TreeNode("Планшеты"));
// удаление у первого узла второго дочернего подузла
treeView1.Nodes[0].Nodes.RemoveAt(1);
// Удаление узла tovarNode и всех его дочерних узлов
treeView1.Nodes.Remove(tovarNode);
```

### Скрытие и раскрытие узлов

Для раскрытия узлов к объекту TreeNode применяется метод Expand(), а для скрытия - метод Collapse():

```cs
// раскрытие узла
tovarNode.Expand();
// раскрытие не только узла, но и всех его дочерних подузлов
tovarNode.ExpandAll();
// скрытие узла
tovarNode.Collapse();
```

### Добавление чекбоксов

Чтобы добавить чекбоксы к узлам дерева, надо у TreeView установить свойство `CheckBoxes = true`:

```cs
treeView1.CheckBoxes = true;
TreeNode smartNode = new TreeNode("Смартфоны");
smartNode.Checked = true;
treeView1.Nodes.Add(smartNode);
treeView1.Nodes.Add(new TreeNode("Планшеты"));
treeView1.Nodes.Add(new TreeNode("Ноутбуки"));
```

![](https://metanit.com/sharp/windowsforms/pics/4.39.png)

### Добавление изображений

Для добавления изображений нам нужен компонент ImageList, в котором имеется несколько картинок. Добавим эти картинки к узлам:

```cs
// установка источника изображений
treeView1.ImageList = imageList1;

TreeNode argentinaNode = new TreeNode { Text = "Аргентина", ImageIndex = 0, SelectedImageIndex = 0 };
treeView1.Nodes.Add(argentinaNode);

TreeNode braziliaNode = new TreeNode { Text = "Бразилия", ImageIndex = 1, SelectedImageIndex = 1 };
treeView1.Nodes.Add(braziliaNode);

TreeNode chilieNode = new TreeNode { Text = "Чили", ImageIndex = 2, SelectedImageIndex = 2 };
treeView1.Nodes.Add(chilieNode);

TreeNode columbiaNode = new TreeNode { Text = "Колумбия", ImageIndex = 3, SelectedImageIndex = 3 };
treeView1.Nodes.Add(columbiaNode);
```

При установке изображений надо учитывать, что если мы не установим свойство `SelectedImageIndex` для каждого узла, то в качестве картинки для выделенного узла по умолчанию будет использоваться первое изображение из ImageList.

### TreeView. Практический пример

Выполним небольшую задачу с TreeView. А именно попробуем сделать примитивный интерфейс на подобие проводника. Для этого добавим на форму элемент TreeView. А в файле кода формы пропишим следующий код:

```cs
namespace HelloApp
{
    public partial class Form1 : Form
    {
        TreeView treeView1;
        public Form1()
        {
            InitializeComponent();
            treeView1 = new();
            treeView1.Dock = DockStyle.Fill;
            Controls.Add(treeView1);
            treeView1.BeforeSelect += treeView1_BeforeSelect;
            treeView1.BeforeExpand += treeView1_BeforeExpand;
            // заполняем дерево дисками
            FillDriveNodes();
        }
        // событие перед раскрытием узла
        void treeView1_BeforeExpand(object? sender, TreeViewCancelEventArgs e)
        {
            e.Node?.Nodes.Clear();
            try
            {
                if (Directory.Exists(e.Node?.FullPath))
                {
                    string[] dirs = Directory.GetDirectories(e.Node.FullPath);
                    foreach (string dir in dirs)
                    {
                        TreeNode dirNode = new TreeNode(new DirectoryInfo(dir).Name);
                        FillTreeNode(dirNode, dir);
                        e.Node.Nodes.Add(dirNode);
                    }
                }
            }
            catch (Exception) { }
        }
        // событие перед выделением узла
        void treeView1_BeforeSelect(object? sender, TreeViewCancelEventArgs e)
        {
            e.Node?.Nodes.Clear();
            try
            {
                if (Directory.Exists(e.Node?.FullPath))
                {
                    string[] dirs = Directory.GetDirectories(e.Node.FullPath);

                    foreach (string dir in dirs)
                    {
                        TreeNode dirNode = new TreeNode(new DirectoryInfo(dir).Name);
                        FillTreeNode(dirNode, dir);
                        e.Node.Nodes.Add(dirNode);
                    }
                }
            }
            catch (Exception) { }
        }

        // получаем все диски на компьютере
        private void FillDriveNodes()
        {
            try
            {
                foreach (DriveInfo drive in DriveInfo.GetDrives())
                {
                    TreeNode driveNode = new TreeNode { Text = drive.Name };
                    FillTreeNode(driveNode, drive.Name);
                    treeView1.Nodes.Add(driveNode);
                }
            }
            catch (Exception) { }
        }
        // получаем дочерние узлы для определенного узла
        private void FillTreeNode(TreeNode driveNode, string path)
        {
            try
            {
                string[] dirs = Directory.GetDirectories(path);
                foreach (string dir in dirs)
                {
                    TreeNode dirNode = new TreeNode();
                    dirNode.Text = dir.Remove(0, dir.LastIndexOf("\\") + 1);
                    driveNode.Nodes.Add(dirNode);
                }
            }
            catch (Exception) { }
        }
    }
}
```

![Проводник в Windows Forms на основе TreeView](https://metanit.com/sharp/windowsforms/pics/4.41.png)

TreeView имеет ряд событий, которые позволяют нам управлять деревом. Наиболее важные из них:

- `BeforeSelect / AfterSelect`: срабатывает перед / после выбора узла дерева
    
- `BeforeExpand / AfterExpand`: срабатывает перед / после раскрытия узла дерева
    
- `BeforeCollapse / AfterCollapse`: срабатывает перед / после скрытия узла дерева
    

В вышеприведенном коде мы заблаговременно перед раскрытием или выбором наполняем выбранный узел дочерними подузлами, благодаря чему у нас появляется видимость, что узлы заполнены.


## 4.12. TrackBar, Timer и ProgressBar

### 4.12.1 TrackBar

TrackBar представляет собой элемент, который с помощью перемещения ползунка позволяет вводить числовые значения.

![Элемент TrackBar в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.42.png)

Некоторые важные свойства TrackBar:

- Orientation: задает ориентацию ползунка - расположение по горизонтали или по вертикали
    
- TickStyle: задает расположение делений на ползунке
    
- TickFrequency: задает частоту делений на ползунке
    
- Minimum: минимальное возможное значение на ползунке (по умолчанию 0)
    
- Maximum: максимальное возможное значение на ползунке (по умолчанию 10)
    
- Value: текущее значение ползунка. Должно находиться между Minimum и Maximum
    

Свойство `TickStyle` может принимать ряд значений:

- `None`: деления отсутствуют
    
- `Both`: деления расположены по обеим сторонам ползунка
    
- `BottomRight`: у вертикального ползунка деления находятся справа, а у горизонтального - снизу
    
- `TopLeft`: у вертикального ползунка деления находятся слева, а у горизонтального - сверху (применяется по умолчанию)
    

К наиболее важным событиям элемента следует отнести событие Scroll, которое позволяет обработать перемещение ползунка от одного деления к другому. Что может быть полезно, если нам надо, например, устанавливать соответствующую громкость звука в зависимости от значения ползунка, либо какике-нибудь другие настройки:

```cs

public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();
        // установка обработчика события Scroll
        trackBar1.Scroll += trackBar1_Scroll;
    }

    private void trackBar1_Scroll(object sender, EventArgs e)
    {
        label1.Text = String.Format("Текущее значение: {0}", trackBar1.Value);
    }
}
```

![Перемещение ползунка в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.43.png)

### 4.12.2 Timer

Timer является компонентом для запуска действий, повторяющихся через определенный промежуток времени. Хотя он не является визуальным элементом, но его аткже можно перетащить с Панели Инструментов на форму:

![Timer в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.44.png)

Наиболее важные свойства и методы таймера:

- Свойство Enabled: при значении true указывает, что таймер будет запускаться вместе с запуском формы
    
- Свойство Interval: указывает интервал в миллисекундах, через который будет срабатывать обработчик события Tick, которое есть у таймера
    
- Метод Start(): запускает таймер
    
- Метод Stop(): останавливает таймер
    

Для примера определим простую форму, на которую добавим кнопку и таймер. В файле кода формы определим следующий код:

```cs
using System.Drawing;

public partial class Form1 : Form
{
    int koef = 1;
    public Form1()
    {
        InitializeComponent();

        this.Width = 400;
        button1.Width = 40;
        button1.Left = 40;
        button1.Text = "";
        button1.BackColor = Color.Aqua;

        timer1.Interval = 500; // 500 миллисекунд
        timer1.Enabled = true;
        button1.Click += button1_Click;
        timer1.Tick += timer1_Tick;
    }
    // обработчик события Tick таймера
    void timer1_Tick(object sender, EventArgs e)
    {
        if (button1.Left == (this.Width - button1.Width - 10))
        {
            koef = -1;
        }
        else if (button1.Left == 0)
        {
            koef = 1;
        }
        button1.Left += 10 * koef;
    }
    // обработчик нажатия на кнопку
    void button1_Click(object sender, EventArgs e)
    {
        if (timer1.Enabled == true)
        {
            timer1.Stop();
        }
        else
        {
            timer1.Start();
        }
    }
}
```

Здесь в конструкторе формы устанавливаются начальные значения для таймера, кнопки и формы.

Через каждый интервал таймера будет срабатывать обработчик `timer1_Tick`, в котором изменяется положение кнопки по горизонтали с помощью свойства `button1.Left`. А с помощью дополнительной переменной `koef` можно управлять направлением движения.

Кроме того, с помощью обраотчика нажатия кнопки `button1_Click` можно либо остановить таймер (и вместе с ним движение кнопки), либо опять его запустить.

![](https://metanit.com/sharp/windowsforms/pics/4.45.png)

### 4.12.3 Индикатор прогресса ProgressBar

Элемент ProgressBar служит для того, чтобы дать пользователю информацию о ходе выполнения какой-либо задачи.

![ProgressBar в Windows Forms](https://metanit.com/sharp/windowsforms/pics/4.46.png)

Наиболее важые свойства ProgressBar:

- Minimum: минимальное возможное значение
    
- Maximum: максимальное возможное значение
    
- Value: текущее значение элемента
    
- Step: шаг, на который изменится значение Value при вызове метода `PerformStep`
    

Для имитации работы прогрессбара поместим на форму таймер и в коде формы определим следующий код:

```cs
public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();

        timer1.Interval = 500; // 500 миллисекунд
        timer1.Enabled = true;
        timer1.Tick += timer1_Tick;
    }
    // обработчик события Tick таймера
    void timer1_Tick(object sender, EventArgs e)
    {
        progressBar1.PerformStep();
    }
}
```